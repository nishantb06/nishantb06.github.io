{
  "blogs": [
    {
      "id": "bigquery-rows-go",
      "title": "Pushing New Rows to BigQuery Using Go",
      "subtitle": "A Guide to Inserting Data into BigQuery Tables with Go",
      "slug": "bigquery-rows-go",
      "author": "Nishant Bhansali",
      "date": "2024-03-15",
      "tags": ["Go", "BigQuery", "Google Cloud Platform", "Data Insertion"],
      "schema": [
        {
          "Introduction": []
        },
        {
          "Prerequisites": []
        },
        {
          "Template": []
        },
        {
          "Understanding the Code": [
            "Struct Definition",
            "Client Creation",
            "Table Specification",
            "Metadata Retrieval",
            "Inserter Creation",
            "Data Preparation",
            "Data Insertion"
          ]
        },
        {
          "Conclusion": []
        }
      ],
      "content": [
        {
          "type": "h2",
          "className": "title",
          "content": "Introduction"
        },
        {
          "type": "p",
          "className": "pb-4",
          "content": "In this blog post, we'll explore how to push new rows into a BigQuery table using Go. BigQuery, a serverless and highly-scalable data warehouse, is a part of Google Cloud Platform (GCP). We will be using the `cloud.google.com/go/bigquery` package for Go to interact with BigQuery."
        },
        {
          "type": "h2",
          "className": "title",
          "content": "Prerequisites"
        },
        {
          "type": "p",
          "className": "pb-4",
          "content": "Before diving into the code, make sure you have the following set up:"
        },
        {
          "type": "ul",
          "className": "pb-4",
          "content": [
            {
              "type": "li",
              "content": "A GCP project with BigQuery enabled"
            },
            {
              "type": "li",
              "content": "Service account credentials in a JSON file"
            },
            {
              "type": "li",
              "content": "Go installed on your machine"
            }
          ]
        },
        {
          "type": "h2",
          "className": "title",
          "content": "Template"
        },
        {
          "type": "pre",
          "className": "pb-4",
          "content": [
            {
              "type": "code",
              "content": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"cloud.google.com/go/bigquery\"\n\t\"google.golang.org/api/option\"\n)\n\n// SampleData represents the structure of the data to be inserted into BigQuery.\ntype SampleData struct {\n\tName  string  `bigquery:\"name\"`   // Name of the data\n\tValue float32 `bigquery:\"value\"`  // Value of the data\n\tTime  string  `bigquery:\"time\"`   // Time when the data was recorded\n}\n\nvar credentialsFile = \"path-to-credentials.json\" // Path to the JSON credentials file\n\n// BatchPushToBigQuery is a function that inserts data into BigQuery in batches.\nfunc BatchPushToBigQuery() {\n\tctx := context.Background()\n\n\t// Create a new BigQuery client using the provided credentials file\n\tclient, err := bigquery.NewClient(ctx, \"your-project-id\", option.WithCredentialsFile(credentialsFile))\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create BigQuery client: %v\", err)\n\t}\n\n\tdataset := client.Dataset(\"dataset-name\") // Specify the dataset name\n\ttable := dataset.Table(\"table-name\")     // Specify the table name\n\n\t// Retrieve the schema for the specified table\n\tmeta, err := table.Metadata(ctx)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to get table meta data: %v\", err)\n\t}\n\n\t// Print the schema of the table\n\tfor _, field := range meta.Schema {\n\t\tfmt.Printf(\"Field Name: %s, Field Type: %s\\n\", field.Name, field.Type)\n\t}\n\n\t// Create sample data to be inserted into the table\n\tdata := SampleData{\n\t\tName:  \"nishant\",\n\t\tValue: 123.123,\n\t\tTime:  time.Now().Format(time.RFC3339),\n\t}\n\n\tdata2 := SampleData{\n\t\tName:  \"nishant2\",\n\t\tValue: 123.123,\n\t\tTime:  time.Now().Format(time.RFC3339),\n\t}\n\n\tinserter := table.Inserter() // Create an inserter for the table\n\titems := []*SampleData{\n\t\t&data,\n\t\t&data2,\n\t}\n\n\t// Insert the data into the table\n\tif err := inserter.Put(ctx, items); err != nil {\n\t\tlog.Fatalf(\"Failed to insert data: %v\", err)\n\t}\n\n\tfmt.Println(\"Data inserted successfully!\")\n}"
            }
          ]
        },
        {
          "type": "h2",
          "className": "title",
          "content": "Understanding the Code"
        },
        {
          "type": "p",
          "className": "pb-4",
          "content": "Let's break down the code you've provided:"
        },
        {
          "type": "h3",
          "className": "title",
          "content": "Struct Definition"
        },
        {
          "type": "pre",
          "className": "pb-4",
          "content": [
            {
              "type": "code",
              "content": "type SampleData struct {\n    Name  string  `bigquery:\"name\"`   // Name of the data\n    Value float32 `bigquery:\"value\"`  // Value of the data\n    Time  string  `bigquery:\"time\"`   // Time when the data was recorded\n}"
            }
          ]
        },
        {
          "type": "p",
          "className": "pb-4",
          "content": "The `SampleData` struct represents the structure of the data to be inserted into BigQuery. The struct tags (`bigquery:\"name\"`, `bigquery:\"value\"`, and `bigquery:\"time\"`) provide metadata to the BigQuery API, mapping the fields of the struct to the corresponding columns in the BigQuery table."
        },
        {
          "type": "h3",
          "className": "title",
          "content": "Client Creation"
        },
        {
          "type": "pre",
          "className": "pb-4",
          "content": [
            {
              "type": "code",
              "content": "client, err := bigquery.NewClient(ctx, \"your-project-id\", option.WithCredentialsFile(credentialsFile))"
            }
          ]
        },
        {
          "type": "p",
          "className": "pb-4",
          "content": "The `bigquery.NewClient` function is used to create a new BigQuery client. It takes the context (`ctx`), project ID, and options (in this case, the path to the JSON credentials file)."
        },
        {
          "type": "h3",
          "className": "title",
          "content": "Table Specification"
        },
        {
          "type": "pre",
          "className": "pb-4",
          "content": [
            {
              "type": "code",
              "content": "dataset := client.Dataset(\"dataset-name\")\ntable := dataset.Table(\"table-name\")"
            }
          ]
        },
        {
          "type": "p",
          "className": "pb-4",
          "content": "Here, we specify the dataset and table within BigQuery where we want to insert the data."
        },
        {
          "type": "h3",
          "className": "title",
          "content": "Metadata Retrieval"
        },
        {
          "type": "pre",
          "className": "pb-4",
          "content": [
            {
              "type": "code",
              "content": "meta, err := table.Metadata(ctx)"
            }
          ]
        },
        {
          "type": "p",
          "className": "pb-4",
          "content": "We retrieve the schema (metadata) of the specified table. The schema includes information about the columns and their types."
        },
        {
          "type": "h3",
          "className": "title",
          "content": "Inserter Creation"
        },
        {
          "type": "pre",
          "className": "pb-4",
          "content": [
            {
              "type": "code",
              "content": "inserter := table.Inserter()"
            }
          ]
        },
        {
          "type": "p",
          "className": "pb-4",
          "content": "An inserter is created for the table, which will be used to insert data."
        },
        {
          "type": "h3",
          "className": "title",
          "content": "Data Preparation"
        },
        {
          "type": "pre",
          "className": "pb-4",
          "content": [
            {
              "type": "code",
              "content": "data := SampleData{\n    Name:  \"nishant\",\n    Value: 123.123,\n    Time:  time.Now().Format(time.RFC3339),\n}"
            }
          ]
        },
        {
          "type": "p",
          "className": "pb-4",
          "content": "Sample data is created using the `SampleData` struct. Note that even if the column datatype is `timestamp` in BigQuery, we have to push a string with proper formatting from our side, which is why we are not using a `time.Time` datatype for this field and using `string` instead."
        },
        {
          "type": "h3",
          "className": "title",
          "content": "Data Insertion"
        },
        {
          "type": "pre",
          "className": "pb-4",
          "content": [
            {
              "type": "code",
              "content": "items := []*SampleData{\n    &data,\n    &data2,\n}\n\nif err := inserter.Put(ctx, items); err != nil {\n    log.Fatalf(\"Failed to insert data: %v\", err)\n}"
            }
          ]
        },
        {
          "type": "p",
          "className": "pb-4",
          "content": "An array of data items is created to be inserted into the table. The data is then inserted into the specified table using the `Put` method of the inserter."
        },
        {
          "type": "h2",
          "className": "title",
          "content": "Conclusion"
        },
        {
          "type": "p",
          "className": "pb-4",
          "content": "In this blog post, we've covered the basics of pushing new rows into a BigQuery table using Go. Understanding the structure of your data, creating a BigQuery client, and utilising the provided libraries for interaction are crucial steps in achieving successful data insertion. This example can be extended for more complex scenarios, such as streaming data or updating existing records. Make sure to check the official documentation for more details and advanced usage."
        }
      ]
    },
    {
      "id": "quantisation-notes",
      "title": "Quantisation Notes",
      "subtitle": "Notes on Quantisation",
      "slug": "quantisation-notes",
      "author": "Nishant Bhansali",
      "date": "2024-05-07",
      "tags": ["quantisation"],
      "schema": [
        {
          "Introduction": [
            "Optimization Methods",
            "Benefits of Scripting Models"
          ]
        },
        {
          "Main Content": [
            "Tracing vs Scripting",
            "Quantization"
          ]
        }
      ],
      "content": [
        {
          "type": "h2",
          "className": "title",
          "content": "Introduction"
        },
        {
          "type": "p",
          "className": "pb-4",
          "content": "There are 4 methods to optimise a model, GPTQ, activation aware quantized training, bits and bytes , packages like huggingface optimum, or pytorch api itself."
        },
        {
          "type": "h3",
          "className": "title",
          "id": "benefits-of-scripting",
          "content": "Benefits of Scripting Models"
        },
        {
          "type": "p",
          "className": "pb-4",
          "content": "Scripting the model can make inference faster for a few reasons:"
        },
        {
          "type": "ul",
          "className": "pb-4",
          "content": [
            {
              "type": "li",
              "content": "Reduced Overhead: Scripted models can have lower overhead compared to their original Python counterparts because the script represents a more optimized version of the model's forward pass. This can lead to faster execution times."
            },
            {
              "type": "li",
              "content": "Optimizations: When you use `torch.jit.script` to script a model, PyTorch applies various optimizations to the script, such as constant folding and operator fusion, which can improve performance during inference."
            },
            {
              "type": "li",
              "content": "Parallelization: Scripted models can take advantage of parallelization opportunities more effectively, especially when deployed on hardware accelerators like GPUs, due to the way the operations are organized and optimized in the script."
            },
            {
              "type": "li",
              "content": "Serialization: Scripted models can be serialized and deserialized more efficiently, which is important for deployment scenarios where models need to be loaded quickly into memory."
            },
            {
              "type": "li",
              "content": "Platform Independence: Scripted models are platform-independent once they are compiled, meaning they can be executed on any platform that supports PyTorch without needing the original Python code, which can be beneficial for deployment in different environments."
            }
          ]
        },
        {
          "type": "p",
          "className": "pb-4",
          "content": "Overall, scripting a model can lead to faster inference times due to these optimizations and efficiencies, especially in production environments where speed and resource usage are critical."
        },
        {
          "type": "h2",
          "className": "title",
          "content": "Main Content"
        },
        {
          "type": "h3",
          "className": "title",
          "id": "tracing-vs-scripting",
          "content": "Tracing vs Scripting"
        },
        {
          "type": "p",
          "className": "pb-4",
          "content": "Tracing a model using torch.jit.trace and torch.jit.script and quantization are two distinct processes in PyTorch, each serving different purposes:"
        },
        {
          "type": "h4",
          "className": "subtitle",
          "content": "Tracing:"
        },
        {
          "type": "ol",
          "className": "pb-4",
          "content": [
            {
              "type": "li",
              "content": "`torch.jit.trace`: This function takes an input tensor and traces the operations that occur during the forward pass of the model. It records the operations as a ScriptModule, which can be used for inference. Tracing is useful for models that have fixed control flow (i.e., the execution of the model does not depend on dynamic conditions like loops or if statements)."
            },
            {
              "type": "li",
              "content": "`torch.jit.script`: This decorator converts a Python function into a ScriptModule, allowing for more flexibility in defining the model's forward method. It is used when the model has dynamic control flow."
            }
          ]
        },
        {
          "type": "h3",
          "className": "title",
          "id": "quantization",
          "content": "Quantization"
        },
        {
          "type": "p",
          "className": "pb-4",
          "content": "Quantization is the process of converting a model to use fewer bits to represent weights and activations, usually from 32-bit floating point to 8-bit integers (or even lower bit representations). This can significantly reduce the model size and improve inference speed, especially on hardware that supports low-precision operations efficiently."
        },
        {
          "type": "p",
          "className": "pb-4",
          "content": "PyTorch provides tools like torch.quantization module to help with quantization, including functions to prepare the model for quantization (torch.quantization.prepare) and to actually quantize the model (torch.quantization.convert)."
        },
        {
          "type": "p",
          "className": "pb-4",
          "content": "In summary, tracing is about capturing the operations of a model to create a script representation for efficient inference, while quantization is about reducing the precision of the model's parameters and activations to improve performance and reduce memory footprint."
        },
        {
          "type": "pre",
          "className": "pb-4",
          "content": [
            {
              "type": "code",
              "content": "function helloWorld() \n\t{ console.log('Hello, World!'); }"
            }
          ]
        }
      ]
    },
    {
      "id": "dev-containers-vscode-docker",
      "title": "Dev Containers: Open Vscode editor inside any Docker image",
      "subtitle": "How to create a dev container",
      "slug": "dev-containers-vscode-docker",
      "author": "Your Name",
      "date": "2023-10-01",
      "tags": ["dev containers", "vscode", "docker"],
      "schema": [
        {
          "Introduction": [
            "Benefits of Dev Containers"
          ]
        },
        {
          "Main Content": [
            "Step 1: Create config files",
            "Step 2: Open dev container"
          ]
        }
      ],
      "content": [
        {
          "type": "h2",
          "className": "title",
          "content": "Introduction"
        },
        {
          "type": "p",
          "className": "pb-4",
          "content": "Let's say you have a docker image for an application and you want to run some test or experiment/add some new feature to that application. Normally I would build that image locally and mount the application directory as volume when I run that container. But something better exists."
        },
        {
          "type": "p",
          "className": "pb-4",
          "content": "Using Dev Containers is better because:"
        },
        {
          "type": "ul",
          "className": "pb-4",
          "content": [
            {
              "type": "li",
              "content": "It gives the VS code experience for any docker image."
            },
            {
              "type": "li",
              "content": "Different VS code extensions can be used here like Linting, Copilot etc."
            },
            {
              "type": "li",
              "content": "Allows reproducibility for any other developer."
            }
          ]
        },
        {
          "type": "p",
          "className": "pb-4",
          "content": "[Video](https://www.youtube.com/watch?v=b1RavPr_878)"
        },
        {
          "type": "h2",
          "className": "title",
          "content": "How to create a dev container"
        },
        {
          "type": "h3",
          "className": "title",
          "content": "Step 1: Create config files"
        },
        {
          "type": "p",
          "className": "pb-4",
          "content": "Open the command palette in VS Code by `CMD + Shift + p` or `Cntrl + Shft + p` if you are in Windows. Type this `Dev Containers: Add dev container config files`. Choose the language you want and any other functionality you want and press enter."
        },
        {
          "type": "p",
          "className": "pb-4",
          "content": "This will create a `devcontainer.json` file inside a `.devcontainer` folder in your root."
        },
        {
          "type": "p",
          "className": "pb-4",
          "content": "This file will look something like this:"
        },
        {
          "type": "pre",
          "className": "pb-4",
          "content": [
            {
              "type": "code",
              "content": "// For format details, see https://aka.ms/devcontainer.json. For config options, see the\n// README at: https://github.com/devcontainers/templates/tree/main/src/go\n{\n\t\"name\": \"Go\",\n\t// Or use a Dockerfile or Docker Compose file. More info: https://containers.dev/guide/dockerfile\n\t\"image\": \"mcr.microsoft.com/devcontainers/go:1-${templateOption:imageVariant}\"\n\n\t// Features to add to the dev container. More info: https://containers.dev/features.\n\t// \"features\": {},\n\n\t// Use 'forwardPorts' to make a list of ports inside the container available locally.\n\t// \"forwardPorts\": [],\n\n\t// Use 'postCreateCommand' to run commands after the container is created.\n\t// \"postCreateCommand\": \"go version\",\n\n\t// Configure tool-specific properties.\n\t// \"customizations\": {},\n\n\t// Uncomment to connect as root instead. More info: https://aka.ms/dev-containers-non-root.\n\t// \"remoteUser\": \"root\"\n}"
            }
          ]
        },
        {
          "type": "p",
          "className": "pb-4",
          "content": "Here replace the name field to whatever is suitable and replace the image field by the name of your own custom image. Can see possible names by running `docker images` in your CLI."
        },
        {
          "type": "p",
          "className": "pb-4",
          "content": "💡 the image provided here is of native Golang, pulled from Microsoft container registry."
        },
        {
          "type": "p",
          "className": "pb-4",
          "content": "Finally it should look something like this:"
        },
        {
          "type": "pre",
          "className": "pb-4",
          "content": [
            {
              "type": "code",
              "content": "// For format details, see https://aka.ms/devcontainer.json. For config options, see the\n// README at: https://github.com/devcontainers/templates/tree/main/src/go\n{\n\t\"name\": \"Go-dummy-app\",\n\t// Or use a Dockerfile or Docker Compose file. More info: https://containers.dev/guide/dockerfile\n\t// \"image\": \"mcr.microsoft.com/devcontainers/go:1-1.21-bullseye\",\n\t\"image\": \"dummy-app\"\n\n\t// Features to add to the dev container. More info: https://containers.dev/features.\n\t// \"features\": {},\n\n\t// Use 'forwardPorts' to make a list of ports inside the container available locally.\n\t// \"forwardPorts\": [],\n\n\t// Use 'postCreateCommand' to run commands after the container is created.\n\t// \"postCreateCommand\": \"go version\",\n\n\t// Configure tool-specific properties.\n\t// \"customizations\": {},\n\n\t// Uncomment to connect as root instead. More info: https://aka.ms/dev-containers-non-root.\n\t// \"remoteUser\": \"root\"\n}"
            }
          ]
        },
        {
          "type": "h3",
          "className": "title",
          "content": "Step 2: Open dev container"
        },
        {
          "type": "p",
          "className": "pb-4",
          "content": "Again open Command palette and type `Dev Container: reopen in container`."
        },
        {
          "type": "p",
          "className": "pb-4",
          "content": "This will take a bit to reload and voila! you should be ready to go now."
        }
      ]
    }
  ]
}